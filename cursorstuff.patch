diff --git a/package.json b/package.json
index aac45ac..c4410e0 100644
--- a/package.json
+++ b/package.json
@@ -173,8 +173,8 @@
     "webpack-merge": "^5.9.0"
   },
   "build": {
-    "productName": "ElectronReact",
-    "appId": "org.erb.ElectronReact",
+    "productName": "Noted",
+    "appId": "org.solomon.noted",
     "asar": true,
     "asarUnpack": "**\\*.{node,dll}",
     "files": [
diff --git a/src/renderer/App.tsx b/src/renderer/App.tsx
index 8651fc5..b41e470 100644
--- a/src/renderer/App.tsx
+++ b/src/renderer/App.tsx
@@ -129,14 +129,49 @@ const InputField = memo(({ effects, idx, task, tasks, setTasks }: {
   const handleTaskInput = useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>, idx: number) => {
     let target = e.target as HTMLTextAreaElement;
     let currentRow = 0;
+    
+    // Mirror the textarea to get the current row
+    if (mirrorRef.current) {
+      mirrorRef.current.style.whiteSpace = 'normal';
+      mirrorRef.current.style.padding = target.style.padding;
+      mirrorRef.current.style.width = target.clientWidth + "px";
+      mirrorRef.current.style.fontFamily = target.style.fontFamily;
+      mirrorRef.current.style.fontSize = target.style.fontSize;
+      mirrorRef.current.style.lineHeight = target.style.lineHeight;
+
+      // Although it may seem logical to attach the prefix to the mirrorRef, there is an edge case where
+      // the word that the cursor is within is longer than the remaining space in the textarea, causing
+      // the word to wrap to the next line. This causes the mirrorRef to be one line behind the actual
+      // textarea.
+      let prefix = target.value.substring(0, target.selectionEnd);
+      mirrorRef.current.textContent = prefix;
+      let remainingText = target.value.substring(target.selectionEnd, target.value.length);
+      let breakIndex = remainingText.indexOf(" ") !== -1 ? remainingText.indexOf(" ") : remainingText.indexOf("\n");
+      if (breakIndex !== -1) {
+        let computedRowToCurrPosition = Math.ceil(mirrorRef.current.clientHeight
+          / parseFloat(window.getComputedStyle(mirrorRef.current).lineHeight!)) - 1;
+        
+        mirrorRef.current.textContent += `${remainingText.substring(0, breakIndex)}`;
+        let computedRowWithFullWordAttached = Math.ceil(mirrorRef.current.clientHeight
+          / parseFloat(window.getComputedStyle(mirrorRef.current).lineHeight!)) - 1;
+
+        mirrorRef.current.textContent = `${target.value.substring(0, target.selectionEnd)}`;
+
+        // If the word is longer than the remaining space in the textarea, then the mirrorRef will be one line behind.
+        if (computedRowWithFullWordAttached > computedRowToCurrPosition) {
+          mirrorRef.current.innerHTML = `${target.value.substring(0, prefix.lastIndexOf(" "))}` + '<br>' + `${target.value.substring(prefix.lastIndexOf(" "), target.selectionEnd)}`;
+        }
+      }
+      currentRow = Math.floor(mirrorRef.current.clientHeight
+        / parseFloat(window.getComputedStyle(mirrorRef.current).lineHeight!)) - 1;
+    }
+    console.debug(currentRow, Math.floor(target.clientHeight / parseFloat(window.getComputedStyle(target).lineHeight!)));
 
     if (e.key == "Enter") {
       e.preventDefault();
       setTasks([...tasks.slice(0, idx), {name: `${target.value.substring(0, target.selectionEnd)}`, done: (target.previousElementSibling as HTMLInputElement).checked}, {name: `${target.value.substring(target.selectionEnd)}`, done: false}, ...tasks.slice(idx + 1)]);
       if ((target.parentElement!.nextElementSibling?.children[1] as HTMLTextAreaElement)) {
         (target.parentElement!.nextElementSibling?.children[1] as HTMLTextAreaElement).focus();
-      } else {
-        console.log(textareaRef.current!);
       }
     } else if (((e.target as HTMLTextAreaElement).value == "" && tasks.length > 1) && (e.key === "Backspace" || e.key === "Delete")) {
       e.preventDefault();
@@ -152,14 +187,14 @@ const InputField = memo(({ effects, idx, task, tasks, setTasks }: {
       let tmpTasks = tasks;
       tmpTasks.splice(idx, 1);
       setTasks(tmpTasks);
-    } else if (e.key === "ArrowUp" && currentRow === 1) {
+    } else if (e.key === "ArrowUp" && currentRow <= 0) {
       e.preventDefault();
       (target.parentElement!.previousElementSibling?.children[1] as HTMLTextAreaElement)?.focus();
-      (document.activeElement as HTMLTextAreaElement).selectionStart = target.selectionStart;
-    } else if (e.key === "ArrowDown" && currentRow === target.rows) {
+      (document.activeElement as HTMLTextAreaElement).selectionStart = 0;
+    } else if (e.key === "ArrowDown" && Math.max(0, currentRow) >= Math.floor(target.clientHeight / parseFloat(window.getComputedStyle(target).lineHeight!)) - 1) {
       e.preventDefault();
       (target.parentElement!.nextElementSibling?.children[1] as HTMLTextAreaElement)?.focus();
-      (document.activeElement as HTMLTextAreaElement).selectionStart = target.selectionStart;
+      (document.activeElement as HTMLTextAreaElement).selectionStart = 0;
     }
   }, [tasks, setTasks]);
 
@@ -186,7 +221,7 @@ const InputField = memo(({ effects, idx, task, tasks, setTasks }: {
         onKeyDown={(e) => handleTaskInput(e, idx)}
         value={task.name}
       />
-      <div className={`hidden`} ref={mirrorRef}></div>
+      <div className="break-words p-1 absolute z-10 left-0 top-0 pointer-events-none opacity-0" ref={mirrorRef}></div>
     </div>
   );
 });
